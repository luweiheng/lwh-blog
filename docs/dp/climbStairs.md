## 1. [爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)

### 题目描述
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

>输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。1. 1 阶 + 1 阶  2. 2 阶

> 输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶； 2. 1 阶 + 2 阶；  3. 2 阶 + 1 阶


### 问题分析
1. 爬楼梯，需要n阶才能到达楼顶，因为每次只能爬1或者2个台阶，所以在n阶的前一阶肯定是 n-2 或者 n-1。
2. 那么可以计算 到达 n-2有多少种方法，到达n-1有多少种方法，计算 n-2 + n-1 的和就可以得出到达n阶有多少总方法。

### 思路
1. 定义一维数组来存储结果，dp[n]表示到达n阶有多少种方法
2. 递推公式 dp[n] = dp[n-1] + dp[n-2]
3. 初始化 dp[1] 到达1阶肯定只有一种方法，所以dp[1]=1, dp[2]到达2阶有两种方法，所以dp[2]=[2]。到达3阶梯有三种方法，故dp[3]=3
4. 遍历顺序从4开始，

### 具体代码实现
```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    //动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。
    
    //边界条件
    if(n<=2){   
        return n;
    }
    
    //动态规划 构建dp表

    //初始化dp表，因为数组从0开始。
    const dp = new Array(n+1).fill(-1);
    dp[0]=0;
    dp[1]=1;
    dp[2]=2;
    dp[3]=3
    for(let index=4;index<=n;index++){
        dp[index]= dp[index-1] + dp[index-2];
    }
    return dp[n];
};
```