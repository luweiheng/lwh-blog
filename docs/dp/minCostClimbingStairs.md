## 1. [最少花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

### 题目描述
> 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
请你计算并返回达到楼梯顶部的最低花费。

>输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

> 输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。


### 问题分析
1. 当站在n阶的时候不需要付费，只有向上爬这个动作发生，才需要支付当前阶梯的费用。

### 思路
1. 定义一维数组来存储结果，dp[n]表示到达n阶梯时的最少花费。
2. 当站在n阶梯时，前一步必然是n-1或者n-2阶梯。
3. 回顾定义dp[n]表示，到达n阶梯的最少费用，那么就应该取下面两个数的min。 dp[n-1]+cost[n-1]、dp[n-2]+cost[n-2];
4. 递推公式：`dp[n] = Math.min(dp[n-1]+cost[n-1],dp[n-2]+cost[n-2])`
5. 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。
所以初始化 dp[0] = 0，dp[1] = 0;
5. 遍历顺序，既可以从2开始，知道n阶梯，即cost.length。

### 具体代码实现
```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
   const len = cost.length;
   const dp = new Array(len + 1);
   dp[0]=0;
   dp[1]=0;
   for(let i = 2; i <= len ; i++){
       dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2]) 
   } 

   return dp[len];
};
```